<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Map Grid Printer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- leaflet-image for exporting map to canvas -->
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>

  <!-- jsPDF for PDF export -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #111827;
    }
    body {
      display: flex;
      overflow: hidden;
    }

    /* Side panel */
    #sidebar {
      width: 340px;
      min-width: 320px;
      max-width: 380px;
      padding: 16px 16px 24px;
      border-right: 1px solid #d1d5db;
      background: #f9fafb;
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
    }
    #sidebar h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 4px;
    }
    #sidebar h2 {
      font-size: 1rem;
      font-weight: 600;
      margin-top: 4px;
      margin-bottom: 4px;
    }
    .section {
      padding: 10px 12px;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.06);
    }

    .field-group {
      display: grid;
      grid-template-columns: 1.2fr 1.1fr;
      gap: 6px 8px;
      align-items: center;
      font-size: 0.85rem;
      margin-top: 4px;
    }
    .field-group label {
      color: #374151;
    }
    .field-group input,
    .field-group select {
      width: 100%;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #cbd5e1;
      font-size: 0.85rem;
    }

    .inline-fields {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }
    .inline-fields > div {
      flex: 1;
    }
    .inline-fields input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #cbd5e1;
      font-size: 0.85rem;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #0f766e;
      background: #0d9488;
      color: #ffffff;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.05s ease;
    }
    button.secondary {
      border-color: #4b5563;
      background: #ffffff;
      color: #111827;
    }
    button:disabled {
      background: #9ca3af;
      border-color: #9ca3af;
      cursor: default;
    }
    button:hover:not(:disabled) {
      background: #0f766e;
      transform: translateY(-0.5px);
    }
    button.secondary:hover:not(:disabled) {
      background: #f3f4f6;
    }

    /* Paper preset / orientation buttons: smaller and grayscale */
    .paper-btn,
    .orient-btn {
      padding: 3px 8px;
      font-size: 0.75rem;
      border-color: #9ca3af;
      background: #e5e7eb;
      color: #374151;
    }
    .paper-btn.paper-active {
      background: #4b5563;
      border-color: #4b5563;
      color: #f9fafb;
    }
    .orient-btn.orient-active {
      background: #4b5563;
      border-color: #4b5563;
      color: #f9fafb;
    }

    .small-note {
      margin-top: 6px;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .status {
      margin-top: 8px;
      font-size: 0.78rem;
      color: #4b5563;
      min-height: 1.2em;
    }

    #map {
      flex: 1;
      height: 100%;
    }

    /* Export overlay */
    #exportOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background: rgba(15, 23, 42, 0.92);
      color: #f9fafb;
      padding: 18px 22px;
      border-radius: 12px;
      font-size: 0.95rem;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      pointer-events: auto;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.3);
    }
    #exportOverlayText {
      font-size: 0.95rem;
    }
    #cancelExportBtn {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #f97316;
      background: #f97316;
      color: #111827;
      font-size: 0.8rem;
      cursor: pointer;
    }
    #cancelExportBtn:hover {
      background: #fb923c;
      border-color: #fb923c;
    }
    #exportOverlayDetail {
      font-size: 0.8rem;
      color: #e5e7eb;
      margin-top: 4px;
      text-align: center;
    }
    #exportProgressBar {
      width: 100%;
      height: 6px;
      background: rgba(148, 163, 184, 0.4);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 8px;
      display: none;
    }
    #exportProgressBarInner {
      width: 0%;
      height: 100%;
      background: #f97316;
      transition: width 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h1>Map Grid Printer</h1>

    <!-- Search -->
    <div class="section">
      <h2>Search</h2>
      <div class="inline-fields">
        <div style="flex: 1.7;">
          <input id="searchInput" type="text" placeholder="地名または住所" />
        </div>
        <div style="flex: 0.9; display: flex; align-items: flex-end;">
          <button id="searchBtn" style="width: 100%;">検索</button>
        </div>
      </div>
    </div>

    <!-- Grid settings -->
    <div class="section">
      <h2>Grid settings</h2>
      <div class="field-group">
        <label for="rows">Rows</label>
        <input id="rows" type="number" min="1" value="5" />

        <label for="cols">Columns</label>
        <input id="cols" type="number" min="1" value="5" />

        <label for="zoomLevel">Zoom</label>
        <input id="zoomLevel" type="number" step="1" min="1" max="22" value="11" />
      </div>

      <p class="small-note">用紙プリセット:</p>
      <div class="button-row">
        <button type="button" class="secondary paper-btn" data-paper="A3">A3</button>
        <button type="button" class="secondary paper-btn" data-paper="A4">A4</button>
        <button type="button" class="secondary paper-btn" data-paper="custom">Custom</button>
      </div>

      <p class="small-note" style="margin-top: 4px;">向き:</p>
      <div class="button-row">
        <button type="button" class="secondary orient-btn" data-orient="landscape">横</button>
        <button type="button" class="secondary orient-btn" data-orient="portrait">縦</button>
      </div>

      <div class="button-row">
        <button id="generateGridBtn">グリッド作成 / 更新</button>
      </div>

      <div class="small-note" style="margin-top: 4px;">
        <label style="display: inline-flex; align-items: center; gap: 4px; cursor: pointer;">
          <input id="lockGrid" type="checkbox" checked />
          <span>グリッドを固定</span>
        </label>
      </div>

      <p class="small-note" id="gridDims"></p>
    </div>

    <!-- Basemap -->
    <div class="section">
      <h2>Basemap</h2>
      <div class="field-group">
        <select id="basemapSelect">
          <option value="esri">ESRI World Imagery</option>
          <option value="gsi1974">GSI 1974</option>
          <option value="gsiPresent">GSI Present</option>
          <option value="gsi1961">GSI 1961</option>
          <option value="gsi1984">GSI 1984</option>
          <option value="googleSat">Google Satellite</option>
          <option value="googleHybrid">Google Hybrid</option>
          <option value="googleMaps">Google Maps</option>
        </select>
      </div>
    </div>

    <!-- GeoJSON overlay -->
    <div class="section">
      <h2>GeoJSON</h2>
      <p class="small-note">GeoJSON の URL を指定してオーバーレイ表示します。</p>
      <div class="field-group">
        <label for="geojsonUrl">URL</label>
        <input
          id="geojsonUrl"
          type="text"
          placeholder="https://raw.githubusercontent.com/yohman/grids/refs/heads/main/takashima.geojson"
        />
      </div>
      <div class="button-row">
        <button id="loadGeojsonBtn" class="secondary">読み込み</button>
        <button id="clearGeojsonBtn" class="secondary">クリア</button>
      </div>
    </div>

    <!-- Export -->
    <div class="section">
      <h2>Export</h2>
      <div class="small-note" style="margin-top: 4px;">
        <label style="display: inline-flex; align-items: center; gap: 4px; cursor: pointer;">
          <input id="showBoundaries" type="checkbox" checked />
          <span>出力画像にグリッド線を表示</span>
        </label>
      </div>
      <div class="button-row">
        <button id="exportBtn">全セルをPDF出力</button>
        <button class="secondary" id="exportOneBtn">現在表示をPNG保存</button>
      </div>
      <div class="field-group" style="margin-top: 4px;">
        <label for="exportRes">解像度</label>
        <select id="exportRes">
          <option value="veryHigh">超高</option>
          <option value="high" selected>高 (推奨)</option>
          <option value="medium">中</option>
          <option value="low">低</option>
        </select>
      </div>
      <div class="status" id="statusText"></div>
    </div>
  </div>

  <div id="map"></div>

  <!-- Export overlay (centered) -->
  <div id="exportOverlay">
    <div id="exportOverlayText"></div>
    <div id="exportOverlayDetail"></div>
    <div id="exportProgressBar">
      <div id="exportProgressBarInner"></div>
    </div>
    <button id="cancelExportBtn" type="button">キャンセル</button>
  </div>

  <script>
    // ===== Constants and globals =====
    const R = 6378137; // WebMercator radius
    let map;
    let baseLayers = {};
    let currentBaseLayer = null;

    let gridCells = []; // [{ row, col, bbox: [[minLng, minLat], [maxLng, maxLat]] }]
    let gridLayer = null;

    let paperMode = "A3"; // "A3" | "A4" | "custom"
    let paperOrientation = "landscape"; // "landscape" | "portrait"
    let gridZoomForExport = null; // zoom used when grid was generated

    let exportResolutionMode = "high"; // "veryHigh" | "high" | "medium" | "low"
    let exportCancelRequested = false;
    let exportTotalCells = 0;

    let geojsonOverlay = null; // GeoJSON overlay layer
    let gridLocked = false;
    const TILE_SIZE = 256; // underlying tile size in pixels

    // Grid dragging state
    let isDraggingGrid = false;
    let dragStartMeters = null;
    let dragStartCells = null;

    // ===== Helpers =====
    function lngLatToMeters(lng, lat) {
      const x = (lng * Math.PI * R) / 180;
      const y = R * Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI) / 360));
      return { x, y };
    }

    function metersToLngLat(x, y) {
      const lng = (x / R) * (180 / Math.PI);
      const lat =
        (180 / Math.PI) *
        (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2);
      return { lng, lat };
    }

    function latLngToWorldPx(lat, lng, z) {
      const scale = TILE_SIZE * Math.pow(2, z);
      const x = ((lng + 180) / 360) * scale;
      const sinLat = Math.sin((lat * Math.PI) / 180);
      const y =
        (0.5 -
          Math.log((1 + sinLat) / (1 - sinLat)) / (4 * Math.PI)) *
        scale;
      return { x, y };
    }

    // Compute a per-cell export zoom to match the desired export resolution for this cell.
    function getTileExportZoomForCell(cell) {
      if (!cell || !cell.bbox) {
        return getTileExportZoom();
      }

      const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;

      // Base pixel size target for the long side of the cell image
      const base = getExportBaseSize(); // e.g. 2000 / 3200 / 4800 px

      // Compute world pixel coordinates at zoom 0 for the cell corners.
      // At zoom z, world pixel distances simply scale by 2^z.
      const sw0 = latLngToWorldPx(minLat, minLng, 0);
      const ne0 = latLngToWorldPx(maxLat, maxLng, 0);
      const w0 = Math.abs(ne0.x - sw0.x);
      const h0 = Math.abs(ne0.y - sw0.y);
      const long0 = Math.max(w0, h0);

      // Fallback if something goes wrong
      if (!isFinite(long0) || long0 <= 0) {
        return getTileExportZoom();
      }

      // We want: longSidePx(z) ≈ base, where longSidePx(z) = long0 * 2^z
      // => 2^z ≈ base / long0  => z ≈ log2(base / long0)
      let z = Math.log2(base / long0);
      if (!isFinite(z)) {
        return getTileExportZoom();
      }
      z = Math.round(z);

      // Determine native zoom limit for the current basemap
      let maxNative = 22;
      if (currentBaseLayer) {
        if (typeof currentBaseLayer.options.maxNativeZoom === "number") {
          maxNative = currentBaseLayer.options.maxNativeZoom;
        } else if (typeof currentBaseLayer.options.maxZoom === "number") {
          maxNative = currentBaseLayer.options.maxZoom;
        }
      }

      // Allow up to +2 beyond native (may result in empty tiles, as desired)
      const maxAllowed = maxNative + 2;

      // Clamp to a sane range
      z = Math.max(0, Math.min(z, maxAllowed));

      return z;
    }

    function getTileExportZoom() {
      if (!map) return 18;

      let zMap = map.getZoom();
      let maxNative = zMap;
      if (
        currentBaseLayer &&
        typeof currentBaseLayer.options.maxNativeZoom === "number"
      ) {
        maxNative = currentBaseLayer.options.maxNativeZoom;
      } else if (currentBaseLayer && typeof currentBaseLayer.options.maxZoom === "number") {
        maxNative = currentBaseLayer.options.maxZoom;
      }

      // Try to go up to 2 levels higher than current view, but never beyond native.
      const target = Math.min(zMap + 2, maxNative);
      return target;
    }

    function getTileTemplate() {
      if (!currentBaseLayer || !currentBaseLayer._url) return null;
      return currentBaseLayer._url;
    }

    function buildTileUrl(template, z, x, y) {
      return template
        .replace("{z}", z)
        .replace("{x}", x)
        .replace("{y}", y);
    }

    async function renderCellViaTiles(cell, tileTemplate) {
      const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;
      const z = getTileExportZoomForCell(cell);

      // Convert cell bbox to world pixel coordinates at zoom z
      const swPx = latLngToWorldPx(minLat, minLng, z);
      const nePx = latLngToWorldPx(maxLat, maxLng, z);

      const minPxX = Math.min(swPx.x, nePx.x);
      const maxPxX = Math.max(swPx.x, nePx.x);
      const minPxY = Math.min(swPx.y, nePx.y);
      const maxPxY = Math.max(swPx.y, nePx.y);

      // Determine tile indices covering this cell
      const maxIndex = Math.pow(2, z) - 1;
      const minTileX = Math.max(0, Math.floor(minPxX / TILE_SIZE));
      const maxTileX = Math.min(maxIndex, Math.floor(maxPxX / TILE_SIZE));
      const minTileY = Math.max(0, Math.floor(minPxY / TILE_SIZE));
      const maxTileY = Math.min(maxIndex, Math.floor(maxPxY / TILE_SIZE));

      const tilesX = maxTileX - minTileX + 1;
      const tilesY = maxTileY - minTileY + 1;

      const tileCount = tilesX * tilesY;

      const stitchWidth = tilesX * TILE_SIZE;
      const stitchHeight = tilesY * TILE_SIZE;

      const stitchCanvas = document.createElement("canvas");
      stitchCanvas.width = stitchWidth;
      stitchCanvas.height = stitchHeight;
      const ctx = stitchCanvas.getContext("2d");

      const loadPromises = [];
      for (let ty = minTileY; ty <= maxTileY; ty++) {
        for (let tx = minTileX; tx <= maxTileX; tx++) {
          const dx = (tx - minTileX) * TILE_SIZE;
          const dy = (ty - minTileY) * TILE_SIZE;
          const url = buildTileUrl(tileTemplate, z, tx, ty);
          loadPromises.push(
            new Promise((resolve) => {
              const img = new Image();
              img.crossOrigin = "anonymous";
              img.onload = function () {
                try {
                  ctx.drawImage(img, dx, dy);
                } catch (e) {
                  console.warn("drawImage failed for", url, e);
                }
                resolve(true);
              };
              img.onerror = function () {
                console.warn("tile load failed:", url);
                resolve(false);
              };
              img.src = url;
            })
          );
        }
      }

      await Promise.all(loadPromises);

      // Crop stitched canvas to the exact cell bounds
      const originWorldX = minTileX * TILE_SIZE;
      const originWorldY = minTileY * TILE_SIZE;

      const cropX = Math.round(minPxX - originWorldX);
      const cropY = Math.round(minPxY - originWorldY);
      const cropW = Math.round(maxPxX - minPxX);
      const cropH = Math.round(maxPxY - minPxY);

      const cropCanvas = document.createElement("canvas");
      cropCanvas.width = cropW;
      cropCanvas.height = cropH;
      const cropCtx = cropCanvas.getContext("2d");

      cropCtx.drawImage(
        stitchCanvas,
        cropX,
        cropY,
        cropW,
        cropH,
        0,
        0,
        cropW,
        cropH
      );

      // --- Scaling for PDF safety and total pixel budget ---
      const PDF_MAX_SIDE = 14000; // just under jsPDF's 14400 userUnit limit
      const maxSide = Math.max(cropW, cropH);

      // First, possible scaling due to PDF side limit
      let scale = 1;
      if (maxSide > PDF_MAX_SIDE) {
        scale = PDF_MAX_SIDE / maxSide;
      }

      // Second, enforce a rough total pixel budget across all cells to avoid jsPDF memory/string limits.
      // This budget is shared by all pages; each cell gets budgetPerCell pixels of area.
      const TOTAL_PIXEL_BUDGET = 120e6; // ~120 million pixels total across the whole PDF
      if (exportTotalCells > 0) {
        const nativeArea = cropW * cropH;
        const budgetPerCell = TOTAL_PIXEL_BUDGET / exportTotalCells;
        if (nativeArea * scale * scale > budgetPerCell) {
          const scaleBudget = Math.sqrt(budgetPerCell / nativeArea);
          scale = Math.min(scale, scaleBudget);
        }
      }

      // If no scaling is needed, return the native crop
      if (scale >= 0.999) {
        return { canvas: cropCanvas, width: cropW, height: cropH, tileCount };
      }

      const targetW = Math.max(1, Math.round(cropW * scale));
      const targetH = Math.max(1, Math.round(cropH * scale));

      const scaledCanvas = document.createElement("canvas");
      scaledCanvas.width = targetW;
      scaledCanvas.height = targetH;
      const scaledCtx = scaledCanvas.getContext("2d");
      scaledCtx.drawImage(
        cropCanvas,
        0,
        0,
        cropW,
        cropH,
        0,
        0,
        targetW,
        targetH
      );

      return { canvas: scaledCanvas, width: targetW, height: targetH, tileCount };
    }

    function setStatus(msg) {
      const el = document.getElementById("statusText");
      if (!el) return;
      el.textContent = msg || "";
    }

    function setGridDimensionsText(msg) {
      const el = document.getElementById("gridDims");
      if (!el) return;
      el.textContent = msg || "";
    }

    function setExportOverlay(text, detail, progressFraction) {
      const container = document.getElementById("exportOverlay");
      if (!container) return;
      const textEl = document.getElementById("exportOverlayText");
      const detailEl = document.getElementById("exportOverlayDetail");
      const barOuter = document.getElementById("exportProgressBar");
      const barInner = document.getElementById("exportProgressBarInner");

      if (text && text.length) {
        if (textEl) textEl.textContent = text;
        if (detailEl) detailEl.textContent = detail || "";
        container.style.display = "flex";

        if (typeof progressFraction === "number" && barOuter && barInner) {
          const clamped = Math.max(0, Math.min(1, progressFraction));
          barOuter.style.display = "block";
          barInner.style.width = (clamped * 100).toFixed(1) + "%";
        } else if (barOuter && barInner) {
          barOuter.style.display = "none";
          barInner.style.width = "0%";
        }
      } else {
        container.style.display = "none";
        if (detailEl) detailEl.textContent = "";
        if (barOuter && barInner) {
          barOuter.style.display = "none";
          barInner.style.width = "0%";
        }
      }
    }

    function getExportBaseSize() {
      switch (exportResolutionMode) {
        case "low":
          return 800;
        case "medium":
          return 2000;
        case "high":
          return 3200;
        case "veryHigh":
          return 4800;
        default:
          return 3200;
      }
    }

    // ===== URL sync =====
    function updateUrlFromState() {
      if (!map) return;
      const params = new URLSearchParams();

      const center = map.getCenter();
      params.set("lat", center.lat.toFixed(6));
      params.set("lng", center.lng.toFixed(6));
      params.set("zoom", map.getZoom().toFixed(2));

      const basemapSelect = document.getElementById("basemapSelect");
      if (basemapSelect) {
        params.set("basemap", basemapSelect.value);
      }

      const rowsInput = document.getElementById("rows");
      const colsInput = document.getElementById("cols");
      if (rowsInput && colsInput && gridCells.length) {
        params.set("rows", rowsInput.value);
        params.set("cols", colsInput.value);
      }

      // Grid bounds
      if (gridCells.length) {
        let minLng = Infinity, minLat = Infinity;
        let maxLng = -Infinity, maxLat = -Infinity;
        gridCells.forEach((cell) => {
          const [[cMinLng, cMinLat], [cMaxLng, cMaxLat]] = cell.bbox;
          if (cMinLng < minLng) minLng = cMinLng;
          if (cMinLat < minLat) minLat = cMinLat;
          if (cMaxLng > maxLng) maxLng = cMaxLng;
          if (cMaxLat > maxLat) maxLat = cMaxLat;
        });
        if (
          isFinite(minLng) && isFinite(minLat) &&
          isFinite(maxLng) && isFinite(maxLat)
        ) {
          params.set("gswLng", minLng.toFixed(6));
          params.set("gswLat", minLat.toFixed(6));
          params.set("gneLng", maxLng.toFixed(6));
          params.set("gneLat", maxLat.toFixed(6));
        }
        params.set("paper", paperMode);
      }
      params.set("orient", paperOrientation);

      const showBoundariesEl = document.getElementById("showBoundaries");
      if (showBoundariesEl) {
        params.set("boundaries", showBoundariesEl.checked ? "1" : "0");
      }

      const lockEl = document.getElementById("lockGrid");
      if (lockEl) {
        params.set("lock", lockEl.checked ? "1" : "0");
      }

      const zoomInputEl = document.getElementById("zoomLevel");
      if (zoomInputEl) {
        params.set("gridZoom", zoomInputEl.value);
      }

      const qs = params.toString();
      const newUrl = qs
        ? `${window.location.pathname}?${qs}`
        : window.location.pathname;
      window.history.replaceState(null, "", newUrl);
    }

    // ===== Grid drag handlers =====
    function onGridMouseDown(e) {
      if (!map || !gridCells.length) return;
      if (gridLocked) return;
      const latlng = e.latlng;
      dragStartMeters = lngLatToMeters(latlng.lng, latlng.lat);
      dragStartCells = gridCells.map((cell) => ({
        row: cell.row,
        col: cell.col,
        bbox: [
          [cell.bbox[0][0], cell.bbox[0][1]],
          [cell.bbox[1][0], cell.bbox[1][1]]
        ]
      }));
      isDraggingGrid = true;
      if (map.dragging && map.dragging.enabled()) {
        map.dragging.disable();
      }
      if (e.originalEvent) {
        L.DomEvent.stopPropagation(e);
        L.DomEvent.preventDefault(e);
      }
    }

    function onGridDragMove(e) {
      if (!isDraggingGrid || !map || !dragStartMeters || !dragStartCells) return;
      const latlng = e.latlng;
      const currentMeters = lngLatToMeters(latlng.lng, latlng.lat);
      const dx = currentMeters.x - dragStartMeters.x;
      const dy = currentMeters.y - dragStartMeters.y;

      const newCells = dragStartCells.map((cell) => {
        const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;
        const minM = lngLatToMeters(minLng, minLat);
        const maxM = lngLatToMeters(maxLng, maxLat);
        const shiftedMin = metersToLngLat(minM.x + dx, minM.y + dy);
        const shiftedMax = metersToLngLat(maxM.x + dx, maxM.y + dy);
        return {
          row: cell.row,
          col: cell.col,
          bbox: [
            [shiftedMin.lng, shiftedMin.lat],
            [shiftedMax.lng, shiftedMax.lat]
          ]
        };
      });

      gridCells = newCells;
      const gridGeoJSON = buildGridGeoJSON(gridCells);
      ensureGridLayer(gridGeoJSON);
    }

    function onGridDragEnd() {
      if (!isDraggingGrid) return;
      isDraggingGrid = false;
      dragStartMeters = null;
      dragStartCells = null;
      if (map && map.dragging && !map.dragging.enabled()) {
        map.dragging.enable();
      }
      updateUrlFromState();
    }

    // ===== Map initialization =====
    function createMap() {
      if (map) {
        map.remove();
        map = null;
      }

      const initialCenter = [35.35, 136.03];

      map = L.map("map", {
        center: initialCenter,
        zoom: 11,
        zoomSnap: 1,   // integer zoom only
        zoomDelta: 1,
        maxZoom: 22
      });

      baseLayers = {
        esri: L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 19,
            attribution:
              "Tiles &copy; Esri &mdash; Source: Esri and others"
          }
        ),
        gsi1974: L.tileLayer(
          "https://cyberjapandata.gsi.go.jp/xyz/gazo1/{z}/{x}/{y}.jpg",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 18,
            attribution: "&copy; GSI Japan 1974"
          }
        ),
        gsiPresent: L.tileLayer(
          "https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 18,
            attribution: "&copy; GSI Japan"
          }
        ),
        gsi1961: L.tileLayer(
          "https://cyberjapandata.gsi.go.jp/xyz/ort_old10/{z}/{x}/{y}.png",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 18,
            attribution: "&copy; GSI Japan 1961"
          }
        ),
        gsi1984: L.tileLayer(
          "https://cyberjapandata.gsi.go.jp/xyz/gazo3/{z}/{x}/{y}.jpg",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 18,
            attribution: "&copy; GSI Japan 1984"
          }
        ),
        googleSat: L.tileLayer(
          "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 21,
            attribution: "Imagery &copy; Google"
          }
        ),
        googleHybrid: L.tileLayer(
          "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 21,
            attribution: "Imagery &copy; Google"
          }
        ),
        googleMaps: L.tileLayer(
          "https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
          {
            tileSize: 256,
            maxZoom: 22,
            maxNativeZoom: 21,
            attribution: "Map data &copy; Google"
          }
        )
      };

      currentBaseLayer = baseLayers.esri;
      currentBaseLayer.addTo(map);

      if (gridCells.length > 0) {
        const gridGeoJSON = buildGridGeoJSON(gridCells);
        ensureGridLayer(gridGeoJSON);
      }

      map.on("mousemove", onGridDragMove);
      map.on("mouseup", onGridDragEnd);
      map.on("mouseleave", onGridDragEnd);

      map.on("moveend", updateUrlFromState);
      map.on("zoomend", () => {
        const zInput = document.getElementById("zoomLevel");
        if (zInput) {
          zInput.value = map.getZoom().toFixed(0);
        }
        updateUrlFromState();
      });
    }

    function setBasemap(key) {
      if (!map || !baseLayers[key]) return;
      if (currentBaseLayer) {
        map.removeLayer(currentBaseLayer);
      }
      currentBaseLayer = baseLayers[key];
      currentBaseLayer.addTo(map);
    }

    // ===== Grid creation =====
    function buildGridGeoJSON(cells) {
      return {
        type: "FeatureCollection",
        features: cells.map((cell) => {
          const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;
          return {
            type: "Feature",
            properties: {
              row: cell.row,
              col: cell.col,
              id: `r${cell.row + 1}_c${cell.col + 1}`
            },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [minLng, minLat],
                [maxLng, minLat],
                [maxLng, maxLat],
                [minLng, maxLat],
                [minLng, minLat]
              ]]
            }
          };
        })
      };
    }

    function ensureGridLayer(gridGeoJSON) {
      if (!map) return;
      if (gridLayer) {
        gridLayer.clearLayers();
        gridLayer.addData(gridGeoJSON);
      } else {
        gridLayer = L.geoJSON(gridGeoJSON, {
          style: {
            color: "#ea580c",
            weight: 1.2,
            fillColor: "#f97316",
            fillOpacity: 0.08
          }
        }).addTo(map);
      }
      if (gridLayer) {
        gridLayer.off("mousedown", onGridMouseDown);
        gridLayer.on("mousedown", onGridMouseDown);
      }
    }

    function generateGrid() {
      if (!map) return;

      const rows = Math.max(
        1,
        parseInt(document.getElementById("rows").value, 10) || 1
      );
      const cols = Math.max(
        1,
        parseInt(document.getElementById("cols").value, 10) || 1
      );

      // Apply desired zoom before reading bounds
      const zoomInput = document.getElementById("zoomLevel");
      if (zoomInput) {
        const desiredZoom = parseFloat(zoomInput.value);
        if (isFinite(desiredZoom)) {
          const center = map.getCenter();
          let maxLayerZoom = map.getMaxZoom();
          if (
            currentBaseLayer &&
            typeof currentBaseLayer.options.maxNativeZoom === "number"
          ) {
            maxLayerZoom = currentBaseLayer.options.maxNativeZoom;
          }
          const targetZoom = Math.min(desiredZoom, maxLayerZoom);
          map.setView(center, targetZoom, { animate: false });
          zoomInput.value = targetZoom.toFixed(0);
        }
      }

      // Always use the *current* map view as the base extent
      const viewBounds = map.getBounds();
      const viewSw = viewBounds.getSouthWest();
      const viewNe = viewBounds.getNorthEast();

      const viewSwM = lngLatToMeters(viewSw.lng, viewSw.lat);
      const viewNeM = lngLatToMeters(viewNe.lng, viewNe.lat);

      const viewWidth = viewNeM.x - viewSwM.x;
      const viewHeight = viewNeM.y - viewSwM.y;

      let swM = { x: viewSwM.x, y: viewSwM.y };
      let neM = { x: viewNeM.x, y: viewNeM.y };
      let totalW = viewWidth;
      let totalH = viewHeight;

      const centerX = (viewSwM.x + viewNeM.x) / 2;
      const centerY = (viewSwM.y + viewNeM.y) / 2;

      // A-series aspect ratio adjustment (sqrt(2)) per cell, based on the current view
      if (paperMode === "A3" || paperMode === "A4") {
        const longOverShort = Math.SQRT2;
        const targetAR =
          paperOrientation === "landscape"
            ? longOverShort
            : 1 / longOverShort; // cell width / cell height

        // We want each cell to have aspect ratio = targetAR, while the entire grid fits in the current view.
        // Let cellWidth = targetAR * cellHeight.
        // Then:
        //   totalWidth  = cols * cellWidth  = cols * targetAR * cellHeight <= viewWidth
        //   totalHeight = rows * cellHeight <= viewHeight
        // So:
        //   cellHeight <= viewHeight / rows
        //   cellHeight <= viewWidth / (cols * targetAR)
        const maxCellHeightByHeight = viewHeight / rows;
        const maxCellHeightByWidth = viewWidth / (cols * targetAR);
        const cellHeightMeters = Math.min(maxCellHeightByHeight, maxCellHeightByWidth);
        const cellWidthMeters = cellHeightMeters * targetAR;

        totalW = cellWidthMeters * cols;
        totalH = cellHeightMeters * rows;

        const halfW = totalW / 2;
        const halfH = totalH / 2;
        swM = { x: centerX - halfW, y: centerY - halfH };
        neM = { x: centerX + halfW, y: centerY + halfH };
      }

      const cellW = totalW / cols;
      const cellH = totalH / rows;

      const cells = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const minX = swM.x + c * cellW;
          const maxX = minX + cellW;
          const minY = swM.y + r * cellH;
          const maxY = minY + cellH;

          const swLL = metersToLngLat(minX, minY);
          const neLL = metersToLngLat(maxX, maxY);

          const bbox = [
            [swLL.lng, swLL.lat],
            [neLL.lng, neLL.lat]
          ];

          cells.push({ row: r, col: c, bbox });
        }
      }

      gridCells = cells;
      const gridGeoJSON = buildGridGeoJSON(gridCells);
      ensureGridLayer(gridGeoJSON);

      // Metrics
      const gridSwLL = metersToLngLat(swM.x, swM.y);
      const gridNeLL = metersToLngLat(neM.x, neM.y);
      const centerLat = (gridSwLL.lat + gridNeLL.lat) / 2;
      const metersPerDegLat = (2 * Math.PI * R) / 360;
      const metersPerDegLng =
        ((2 * Math.PI * R) / 360) * Math.cos((centerLat * Math.PI) / 180);

      const gridWidthKmApprox =
        ((gridNeLL.lng - gridSwLL.lng) * metersPerDegLng) / 1000;
      const gridHeightKmApprox =
        ((gridNeLL.lat - gridSwLL.lat) * metersPerDegLat) / 1000;

      const cellWidthKmApprox = gridWidthKmApprox / cols;
      const cellHeightKmApprox = gridHeightKmApprox / rows;
      const cellAspect =
        cellHeightKmApprox !== 0
          ? cellWidthKmApprox / cellHeightKmApprox
          : NaN;

      const zoomNow = map.getZoom();
      gridZoomForExport = zoomNow;

      const dimsText = `現在のグリッド: ズーム ${zoomNow.toFixed(
        0
      )}, 全体 ≈ ${gridWidthKmApprox.toFixed(
        3
      )} × ${gridHeightKmApprox.toFixed(
        3
      )} km; 1セル ≈ ${cellWidthKmApprox.toFixed(
        3
      )} × ${cellHeightKmApprox.toFixed(
        3
      )} km (縦横比 ${
        isFinite(cellAspect) ? cellAspect.toFixed(3) : "–"
      }, 用紙モード ${paperMode} / ${
        paperOrientation === "landscape" ? "横" : "縦"
      }).`;

      setGridDimensionsText(dimsText);
      setStatus(`グリッドを作成しました: ${rows} × ${cols}。${dimsText}`);

      const zoomInputEl = document.getElementById("zoomLevel");
      if (zoomInputEl) {
        zoomInputEl.value = zoomNow.toFixed(0);
      }

      updateUrlFromState();
    }

    // ===== Search =====
    function searchLocation() {
      if (!map) return;
      const q = document.getElementById("searchInput").value.trim();
      if (!q) return;
      setStatus(`「${q}」を検索中です…`);
      fetch(
        "https://nominatim.openstreetmap.org/search?format=json&q=" +
        encodeURIComponent(q)
      )
        .then((res) => res.json())
        .then((data) => {
          if (!data || !data.length) {
            setStatus(`「${q}」は見つかりませんでした。`);
            return;
          }
          const best = data[0];
          const lat = parseFloat(best.lat);
          const lon = parseFloat(best.lon);
          map.flyTo([lat, lon], 12);
          setStatus("場所を移動しました: " + best.display_name);
        })
        .catch((err) => {
          console.error(err);
          setStatus("検索に失敗しました。もう一度お試しください。");
        });
    }

    // ===== GeoJSON overlay =====
    function loadGeoJSONFromUrl() {
      if (!map) return;
      const input = document.getElementById("geojsonUrl");
      if (!input) return;
      const url = input.value.trim();
      if (!url) {
        setStatus("GeoJSON の URL を入力してください。");
        return;
      }
      setStatus("GeoJSON を読み込み中です...");
      fetch(url)
        .then((res) => {
          if (!res.ok) throw new Error("HTTP " + res.status);
          return res.json();
        })
        .then((data) => {
          if (geojsonOverlay && map.hasLayer(geojsonOverlay)) {
            map.removeLayer(geojsonOverlay);
          }
          geojsonOverlay = L.geoJSON(data, {
            style: {
              color: "#ef4444",
              weight: 2,
              fillColor: "#ef4444",
              fillOpacity: 0.0
            }
          }).addTo(map);
          try {
            const b = geojsonOverlay.getBounds();
            if (b.isValid()) {
              map.fitBounds(b, { animate: true });
            }
          } catch (e) {
            console.warn("Could not fit bounds for GeoJSON overlay:", e);
          }
          setStatus("GeoJSON レイヤーを読み込みました。");
        })
        .catch((err) => {
          console.error(err);
          setStatus("GeoJSON の読み込みに失敗しました。CORS や URL を確認してください。");
        });
    }

    function clearGeoJSONOverlay() {
      if (!map) return;
      if (geojsonOverlay && map.hasLayer(geojsonOverlay)) {
        map.removeLayer(geojsonOverlay);
      }
      geojsonOverlay = null;
      setStatus("GeoJSON レイヤーをクリアしました。");
    }

    // ===== Export current view (PNG) =====
    function exportCurrentView() {
      if (!map) return;
      const showBoundariesEl = document.getElementById("showBoundaries");
      const showBoundaries = !showBoundariesEl || showBoundariesEl.checked;

      const mapDiv = document.getElementById("map");
      if (!mapDiv) {
        setStatus("エクスポートに失敗しました（マップ要素なし）。");
        return;
      }

      let removedGrid = false;
      if (!showBoundaries && gridLayer && map.hasLayer(gridLayer)) {
        map.removeLayer(gridLayer);
        removedGrid = true;
      }

      const originalWidth = mapDiv.style.width;
      const originalHeight = mapDiv.style.height;
      const originalSize = map.getSize();
      const aspect =
        originalSize.x > 0 && originalSize.y > 0
          ? originalSize.x / originalSize.y
          : 1;

      const base = getExportBaseSize();
      let targetW, targetH;
      if (aspect >= 1) {
        targetW = base;
        targetH = Math.round(base / aspect);
      } else {
        targetH = base;
        targetW = Math.round(base * aspect);
      }

      mapDiv.style.width = targetW + "px";
      mapDiv.style.height = targetH + "px";
      map.invalidateSize();

      try {
        leafletImage(map, (err, canvas) => {
          mapDiv.style.width = originalWidth;
          mapDiv.style.height = originalHeight;
          map.invalidateSize();

          if (removedGrid && gridLayer && !map.hasLayer(gridLayer)) {
            gridLayer.addTo(map);
          }

          if (err) {
            console.error(err);
            setStatus("エクスポートに失敗しました（描画エラー）。");
            return;
          }

          const dataURL = canvas.toDataURL("image/png");
          const link = document.createElement("a");
          const ts = new Date().toISOString().replace(/[:.]/g, "-");
          link.href = dataURL;
          link.download = `map_view_${ts}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setStatus("現在の表示を PNG として保存しました。");
        });
      } catch (e) {
        console.error(e);
        setStatus("エクスポートに失敗しました（ブラウザの権限を確認してください）。");
        mapDiv.style.width = originalWidth;
        mapDiv.style.height = originalHeight;
        map.invalidateSize();
        if (removedGrid && gridLayer && !map.hasLayer(gridLayer)) {
          gridLayer.addTo(map);
        }
      }
    }

    // ===== Export all cells to one PDF (tile-based, native resolution) =====
    async function exportAllCells() {
      if (!map) return;
      if (!gridCells.length) {
        alert("先にグリッドを作成してください。");
        return;
      }

      const tileTemplate = getTileTemplate();
      if (!tileTemplate) {
        setStatus("現在のベースマップはタイルエクスポートに対応していません。別のベースマップを試してください。");
        return;
      }

      exportCancelRequested = false;

      const exportBtn = document.getElementById("exportBtn");
      const exportOneBtn = document.getElementById("exportOneBtn");
      exportBtn.disabled = true;
      exportOneBtn.disabled = true;

      const { jsPDF } = window.jspdf;
      let pdf = null;

      const total = gridCells.length;
      exportTotalCells = total;
      let totalTilesSoFar = 0;

      const showBoundariesEl = document.getElementById("showBoundaries");
      const showBoundaries = !showBoundariesEl || showBoundariesEl.checked;

      setStatus(`セル 1 / ${total} を出力中...`);
      setExportOverlay(`セル 1 / ${total} を出力中...`, "", 0);

      function finalizeExport({ save, message }) {
        if (save && pdf) {
          pdf.save("map_grid.pdf");
        }
        exportTotalCells = 0;
        exportBtn.disabled = false;
        exportOneBtn.disabled = false;
        setStatus(message);
        setExportOverlay("");
      }

      try {
        for (let index = 0; index < total; index++) {
          if (exportCancelRequested) {
            finalizeExport({
              save: false,
              message: "エクスポートをキャンセルしました。"
            });
            return;
          }

          const cell = gridCells[index];
          const stepText = `セル ${index + 1} / ${total} を出力中...`;
          setStatus(stepText);

          const {
            canvas: cropCanvas,
            width: cropW,
            height: cropH,
            tileCount
          } = await renderCellViaTiles(cell, tileTemplate);

          totalTilesSoFar += (tileCount || 0);
          const detailText = `このセル: 約 ${tileCount || 0} タイル / 累計: 約 ${totalTilesSoFar} タイル`;
          const progress = total > 0 ? (index + 1) / total : 0;
          setExportOverlay(stepText, detailText, progress);

          // Optionally draw a thin boundary on the very edge of the exported image
          if (showBoundaries) {
            const bctx = cropCanvas.getContext("2d");
            const lw = Math.max(1, Math.round(Math.min(cropW, cropH) / 400));
            bctx.strokeStyle = "rgba(234,88,12,0.9)";
            bctx.lineWidth = lw;
            bctx.strokeRect(
              lw / 2,
              lw / 2,
              cropW - lw,
              cropH - lw
            );
          }

          const dataURL = cropCanvas.toDataURL("image/png");

          if (!pdf) {
            const orientation = cropW >= cropH ? "landscape" : "portrait";
            pdf = new jsPDF({
              orientation,
              unit: "px",
              format: [cropW, cropH]
            });
          } else {
            pdf.addPage(
              [cropW, cropH],
              cropW >= cropH ? "landscape" : "portrait"
            );
          }

          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();
          pdf.addImage(dataURL, "PNG", 0, 0, pageWidth, pageHeight);
        }

        finalizeExport({
          save: true,
          message: `エクスポート完了: ${total} セルを PDF に保存しました。`
        });
      } catch (e) {
        console.error(e);
        finalizeExport({
          save: !!pdf,
          message: "タイルエクスポート中にエラーが発生しました。"
        });
      }
    }

    // ===== DOMContentLoaded wiring =====
    window.addEventListener("DOMContentLoaded", () => {
      const params = new URLSearchParams(window.location.search);

      createMap();

      const zoomInputEl = document.getElementById("zoomLevel");
      if (zoomInputEl && map) {
        zoomInputEl.value = map.getZoom().toFixed(0);
      }

      // Lock grid
      const lockEl = document.getElementById("lockGrid");
      if (lockEl) {
        if (params.has("lock")) {
          lockEl.checked = params.get("lock") === "1";
        }
        gridLocked = lockEl.checked;
        lockEl.addEventListener("change", () => {
          gridLocked = lockEl.checked;
          updateUrlFromState();
        });
      }

      // Show boundaries
      const showBoundariesEl = document.getElementById("showBoundaries");
      if (showBoundariesEl) {
        if (params.has("boundaries")) {
          showBoundariesEl.checked = params.get("boundaries") !== "0";
        }
        showBoundariesEl.addEventListener("change", () => {
          updateUrlFromState();
        });
      }

      // Basemap restore
      const basemapSelect = document.getElementById("basemapSelect");
      if (basemapSelect && params.has("basemap")) {
        const key = params.get("basemap");
        if (key && baseLayers[key]) {
          basemapSelect.value = key;
          setBasemap(key);
        }
      }

      // Center/zoom restore
      if (params.has("lat") && params.has("lng")) {
        const lat = parseFloat(params.get("lat"));
        const lng = parseFloat(params.get("lng"));
        if (isFinite(lat) && isFinite(lng)) {
          let zoom = map.getZoom();
          if (params.has("zoom")) {
            const zParam = parseFloat(params.get("zoom"));
            if (isFinite(zParam)) zoom = zParam;
          }
          map.setView([lat, lng], zoom, { animate: false });
          if (zoomInputEl) zoomInputEl.value = zoom.toFixed(0);
        }
      } else if (params.has("zoom")) {
        const zParam = parseFloat(params.get("zoom"));
        if (isFinite(zParam)) {
          const center = map.getCenter();
          map.setView(center, zParam, { animate: false });
          if (zoomInputEl) zoomInputEl.value = zParam.toFixed(0);
        }
      }

      // Rows/cols/zoom for grid
      const rowsInput = document.getElementById("rows");
      const colsInput = document.getElementById("cols");
      if (rowsInput && params.has("rows")) {
        rowsInput.value = params.get("rows");
      }
      if (colsInput && params.has("cols")) {
        colsInput.value = params.get("cols");
      }
      if (zoomInputEl && params.has("gridZoom")) {
        const gz = parseFloat(params.get("gridZoom"));
        zoomInputEl.value = params.get("gridZoom");
        if (isFinite(gz)) {
          gridZoomForExport = gz;
        }
      }

      // Paper mode
      if (params.has("paper")) {
        const p = params.get("paper");
        if (p === "A3" || p === "A4" || p === "custom") {
          paperMode = p;
        }
      }

      // Orientation
      if (params.has("orient")) {
        const o = params.get("orient");
        if (o === "landscape" || o === "portrait") {
          paperOrientation = o;
        }
      }

      // Restore grid from URL bounds
      if (
        params.has("rows") &&
        params.has("cols") &&
        params.has("gswLng") &&
        params.has("gswLat") &&
        params.has("gneLng") &&
        params.has("gneLat")
      ) {
        const rows = Math.max(1, parseInt(params.get("rows"), 10) || 1);
        const cols = Math.max(1, parseInt(params.get("cols"), 10) || 1);
        const swLng = parseFloat(params.get("gswLng"));
        const swLat = parseFloat(params.get("gswLat"));
        const neLng = parseFloat(params.get("gneLng"));
        const neLat = parseFloat(params.get("gneLat"));

        if (
          isFinite(swLng) && isFinite(swLat) &&
          isFinite(neLng) && isFinite(neLat)
        ) {
          const swM = lngLatToMeters(swLng, swLat);
          const neM = lngLatToMeters(neLng, neLat);
          const totalW = neM.x - swM.x;
          const totalH = neM.y - swM.y;
          const cellW = totalW / cols;
          const cellH = totalH / rows;

          const cells = [];
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const minX = swM.x + c * cellW;
              const maxX = minX + cellW;
              const minY = swM.y + r * cellH;
              const maxY = minY + cellH;

              const swLL = metersToLngLat(minX, minY);
              const neLL = metersToLngLat(maxX, maxY);

              const bbox = [
                [swLL.lng, swLL.lat],
                [neLL.lng, neLL.lat]
              ];
              cells.push({ row: r, col: c, bbox });
            }
          }

          gridCells = cells;
          const gridGeoJSON = buildGridGeoJSON(gridCells);
          ensureGridLayer(gridGeoJSON);

          const gridSwLL = { lng: swLng, lat: swLat };
          const gridNeLL = { lng: neLng, lat: neLat };
          const centerLat = (gridSwLL.lat + gridNeLL.lat) / 2;
          const metersPerDegLat = (2 * Math.PI * R) / 360;
          const metersPerDegLng =
            ((2 * Math.PI * R) / 360) * Math.cos((centerLat * Math.PI) / 180);

          const gridWidthKmApprox =
            ((gridNeLL.lng - gridSwLL.lng) * metersPerDegLng) / 1000;
          const gridHeightKmApprox =
            ((gridNeLL.lat - gridSwLL.lat) * metersPerDegLat) / 1000;

          const cellWidthKmApprox = gridWidthKmApprox / cols;
          const cellHeightKmApprox = gridHeightKmApprox / rows;
          const cellAspect =
            cellHeightKmApprox !== 0
              ? cellWidthKmApprox / cellHeightKmApprox
              : NaN;

          const zoomNow = map.getZoom();
          gridZoomForExport = zoomNow;

          const dimsText = `現在のグリッド: ズーム ${zoomNow.toFixed(
            0
          )}, 全体 ≈ ${gridWidthKmApprox.toFixed(
            3
          )} × ${gridHeightKmApprox.toFixed(
            3
          )} km; 1セル ≈ ${cellWidthKmApprox.toFixed(
            3
          )} × ${cellHeightKmApprox.toFixed(
            3
          )} km (縦横比 ${
              isFinite(cellAspect) ? cellAspect.toFixed(3) : "–"
            }, 用紙モード ${paperMode} / ${
              paperOrientation === "landscape" ? "横" : "縦"
            }).`;

          setGridDimensionsText(dimsText);
          setStatus(`URL からグリッドを復元しました。${dimsText}`);

          if (!(params.has("lat") && params.has("lng"))) {
            const gridBounds = L.latLngBounds(
              L.latLng(swLat, swLng),
              L.latLng(neLat, neLng)
            );
            map.fitBounds(gridBounds, { animate: false });
          }
        }
      }

      // Paper preset buttons
      const paperButtons = Array.from(document.querySelectorAll(".paper-btn"));
      function updatePaperButtons() {
        paperButtons.forEach((btn) => {
          const mode = btn.getAttribute("data-paper");
          if (mode === paperMode) {
            btn.classList.add("paper-active");
          } else {
            btn.classList.remove("paper-active");
          }
        });
      }
      paperButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const mode = btn.getAttribute("data-paper");
          if (!mode) return;
          paperMode = mode;
          updatePaperButtons();
          setStatus(
            `用紙モードを ${paperMode} に変更しました。グリッドを再生成してください。`
          );
          updateUrlFromState();
        });
      });
      updatePaperButtons();

      // Orientation buttons
      const orientButtons = Array.from(document.querySelectorAll(".orient-btn"));
      function updateOrientButtons() {
        orientButtons.forEach((btn) => {
          const o = btn.getAttribute("data-orient");
          if (o === paperOrientation) {
            btn.classList.add("orient-active");
          } else {
            btn.classList.remove("orient-active");
          }
        });
      }
      orientButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const o = btn.getAttribute("data-orient");
          if (!o) return;
          if (o === "landscape" || o === "portrait") {
            paperOrientation = o;
            updateOrientButtons();
            setStatus(
              `用紙の向きを ${paperOrientation === "landscape" ? "横" : "縦"
              } に変更しました。グリッドを再生成してください。`
            );
            updateUrlFromState();
          }
        });
      });
      updateOrientButtons();

      // Buttons / controls
      document
        .getElementById("generateGridBtn")
        .addEventListener("click", generateGrid);

      document
        .getElementById("basemapSelect")
        .addEventListener("change", (e) => {
          setBasemap(e.target.value);
          updateUrlFromState();
        });

      document
        .getElementById("exportBtn")
        .addEventListener("click", exportAllCells);

      document
        .getElementById("exportOneBtn")
        .addEventListener("click", exportCurrentView);

      document
        .getElementById("searchBtn")
        .addEventListener("click", searchLocation);

      document
        .getElementById("searchInput")
        .addEventListener("keydown", (e) => {
          if (e.key === "Enter") searchLocation();
        });

      const loadGeojsonBtn = document.getElementById("loadGeojsonBtn");
      if (loadGeojsonBtn) {
        loadGeojsonBtn.addEventListener("click", loadGeoJSONFromUrl);
      }
      const clearGeojsonBtn = document.getElementById("clearGeojsonBtn");
      if (clearGeojsonBtn) {
        clearGeojsonBtn.addEventListener("click", clearGeoJSONOverlay);
      }

      const exportResSelect = document.getElementById("exportRes");
      if (exportResSelect) {
        exportResSelect.value = exportResolutionMode;
        exportResSelect.addEventListener("change", (e) => {
          const val = e.target.value;
          if (
            val === "low" ||
            val === "medium" ||
            val === "high" ||
            val === "veryHigh"
          ) {
            exportResolutionMode = val;
          } else {
            exportResolutionMode = "high";
          }
        });
      }

      const cancelBtn = document.getElementById("cancelExportBtn");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", () => {
          if (!exportCancelRequested) {
            exportCancelRequested = true;
            setStatus("エクスポートをキャンセルしています...");
          }
        });
      }

      updateUrlFromState();
    });
  </script>
</body>
</html>