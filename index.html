<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Map Grid Printer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- MapLibre -->
  <link
    href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>

  <!-- jsPDF for PDF export -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #111827;
    }
    body {
      display: flex;
      overflow: hidden;
    }

    /* Side panel */
    #sidebar {
      width: 340px;
      min-width: 320px;
      max-width: 380px;
      padding: 16px 16px 24px;
      border-right: 1px solid #d1d5db;
      background: #f9fafb;
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
    }
    #sidebar h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 4px;
    }
    #sidebar h2 {
      font-size: 1rem;
      font-weight: 600;
      margin-top: 4px;
      margin-bottom: 4px;
    }
    .section {
      padding: 10px 12px;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.06);
    }

    .field-group {
      display: grid;
      grid-template-columns: 1.2fr 1.1fr;
      gap: 6px 8px;
      align-items: center;
      font-size: 0.85rem;
      margin-top: 4px;
    }
    .field-group label {
      color: #374151;
    }
    .field-group input,
    .field-group select {
      width: 100%;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #cbd5e1;
      font-size: 0.85rem;
    }

    .inline-fields {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }
    .inline-fields > div {
      flex: 1;
    }
    .inline-fields input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #cbd5e1;
      font-size: 0.85rem;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #0f766e;
      background: #0d9488;
      color: #ffffff;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.05s ease;
    }
    button.secondary {
      border-color: #4b5563;
      background: #ffffff;
      color: #111827;
    }
    button:disabled {
      background: #9ca3af;
      border-color: #9ca3af;
      cursor: default;
    }
    button:hover:not(:disabled) {
      background: #0f766e;
      transform: translateY(-0.5px);
    }
    button.secondary:hover:not(:disabled) {
      background: #f3f4f6;
    }

    /* Paper preset / orientation buttons: smaller and grayscale */
    .paper-btn,
    .orient-btn {
      padding: 3px 8px;
      font-size: 0.75rem;
      border-color: #9ca3af;
      background: #e5e7eb;
      color: #374151;
    }
    .paper-btn.paper-active {
      background: #4b5563;
      border-color: #4b5563;
      color: #f9fafb;
    }
    .orient-btn.orient-active {
      background: #4b5563;
      border-color: #4b5563;
      color: #f9fafb;
    }

    .small-note {
      margin-top: 6px;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .status {
      margin-top: 8px;
      font-size: 0.78rem;
      color: #4b5563;
      min-height: 1.2em;
    }

    #map {
      flex: 1;
      height: 100%;
    }

    /* MapLibre map canvas */
    .maplibregl-map {
      font: inherit;
    }

    /* Export overlay */
    #exportOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background: rgba(15, 23, 42, 0.92);
      color: #f9fafb;
      padding: 18px 22px;
      border-radius: 12px;
      font-size: 0.95rem;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      pointer-events: auto;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.3);
    }
    #exportOverlayText {
      font-size: 0.95rem;
    }
    #cancelExportBtn {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #f97316;
      background: #f97316;
      color: #111827;
      font-size: 0.8rem;
      cursor: pointer;
    }
    #cancelExportBtn:hover {
      background: #fb923c;
      border-color: #fb923c;
    }
    #exportOverlayDetail {
      font-size: 0.8rem;
      color: #e5e7eb;
      margin-top: 4px;
      text-align: center;
    }
    #exportProgressBar {
      width: 100%;
      height: 6px;
      background: rgba(148, 163, 184, 0.4);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 8px;
      display: none;
    }
    #exportProgressBarInner {
      width: 0%;
      height: 100%;
      background: #f97316;
      transition: width 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h1>Map Grid Printer</h1>

    <!-- Search -->
    <div class="section">
      <h2>Search</h2>
      <div class="inline-fields">
        <div style="flex: 1.7;">
          <input id="searchInput" type="text" placeholder="地名または住所" />
        </div>
        <div style="flex: 0.9; display: flex; align-items: flex-end;">
          <button id="searchBtn" style="width: 100%;">検索</button>
        </div>
      </div>
    </div>

    <!-- Grid settings -->
    <div class="section">
      <h2>Grid settings</h2>
      <div class="field-group">
        <label for="rows">Rows</label>
        <input id="rows" type="number" min="1" value="5" />

        <label for="cols">Columns</label>
        <input id="cols" type="number" min="1" value="5" />

        <label for="zoomLevel">Zoom</label>
        <input id="zoomLevel" type="number" step="1" min="1" max="22" value="11" />
      </div>

      <p class="small-note">用紙プリセット:</p>
      <div class="button-row">
        <button type="button" class="secondary paper-btn" data-paper="A3">A3</button>
        <button type="button" class="secondary paper-btn" data-paper="A4">A4</button>
        <button type="button" class="secondary paper-btn" data-paper="custom">Custom</button>
      </div>

      <p class="small-note" style="margin-top: 4px;">向き:</p>
      <div class="button-row">
        <button type="button" class="secondary orient-btn" data-orient="landscape">横</button>
        <button type="button" class="secondary orient-btn" data-orient="portrait">縦</button>
      </div>

      <div class="button-row">
        <button id="generateGridBtn">グリッド作成 / 更新</button>
      </div>

      <div class="small-note" style="margin-top: 4px;">
        <label style="display: inline-flex; align-items: center; gap: 4px; cursor: pointer;">
          <input id="lockGrid" type="checkbox" checked />
          <span>グリッドを固定</span>
        </label>
      </div>

      <p class="small-note" id="gridDims"></p>
    </div>

    <!-- Basemap -->
    <div class="section">
      <h2>Basemap</h2>
      <div class="field-group">
        <select id="basemapSelect">
          <option value="esri">ESRI World Imagery</option>
          <option value="gsi1974">GSI 1974</option>
          <option value="gsiPresent">GSI Present</option>
          <option value="gsi1961">GSI 1961</option>
          <option value="gsi1984">GSI 1984</option>
          <option value="googleSat">Google Satellite</option>
          <option value="googleHybrid">Google Hybrid</option>
          <option value="googleMaps">Google Maps</option>
        </select>
      </div>
    </div>

    <!-- GeoJSON overlay -->
    <div class="section">
      <h2>GeoJSON</h2>
      <p class="small-note">GeoJSON の URL を指定してオーバーレイ表示します。</p>
      <div class="field-group">
        <label for="geojsonUrl">URL</label>
        <input
          id="geojsonUrl"
          type="text"
          placeholder="https://raw.githubusercontent.com/yohman/grids/refs/heads/main/takashima.geojson"
        />
      </div>
      <div class="button-row">
        <button id="loadGeojsonBtn" class="secondary">読み込み</button>
        <button id="clearGeojsonBtn" class="secondary">クリア</button>
      </div>
    </div>

    <!-- Export -->
    <div class="section">
      <h2>Export</h2>
      <div class="small-note" style="margin-top: 4px;">
        <label style="display: inline-flex; align-items: center; gap: 4px; cursor: pointer;">
          <input id="showBoundaries" type="checkbox" checked />
          <span>出力画像にグリッド線を表示</span>
        </label>
      </div>
      <div class="button-row">
        <button id="exportBtn">全セルをPDF出力</button>
        <button class="secondary" id="exportOneBtn">現在表示をPNG保存</button>
      </div>
      <div class="field-group" style="margin-top: 4px;">
        <label for="exportRes">解像度</label>
        <select id="exportRes">
          <option value="veryHigh">超高</option>
          <option value="high" selected>高 (推奨)</option>
          <option value="medium">中</option>
          <option value="low">低</option>
        </select>
      </div>
      <div class="status" id="statusText"></div>
    </div>
  </div>

  <div id="map"></div>

  <!-- Export overlay (centered) -->
  <div id="exportOverlay">
    <div id="exportOverlayText"></div>
    <div id="exportOverlayDetail"></div>
    <div id="exportProgressBar">
      <div id="exportProgressBarInner"></div>
    </div>
    <button id="cancelExportBtn" type="button">キャンセル</button>
  </div>

  <script>
    // ===== Constants and globals =====
    const R = 6378137; // WebMercator radius
    const TILE_SIZE = 256;

    let map;
    let gridCells = []; // [{row,col,bbox:[[minLng,minLat],[maxLng,maxLat]]}]
    let paperMode = "A3";
    let paperOrientation = "landscape";
    let gridZoomForExport = null;

    let exportResolutionMode = "high";
    let exportCancelRequested = false;
    let exportTotalCells = 0;

    let gridLocked = false;
    let isDraggingGrid = false;
    let dragStartMeters = null;
    let dragStartCells = null;

    let currentBaseKey = "esri";

    const basemapConfigs = {
      esri: {
        template:
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        maxZoom: 22,
        maxNativeZoom: 19
      },
      gsi1974: {
        template:
          "https://cyberjapandata.gsi.go.jp/xyz/gazo1/{z}/{x}/{y}.jpg",
        maxZoom: 22,
        maxNativeZoom: 18
      },
      gsiPresent: {
        template:
          "https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg",
        maxZoom: 22,
        maxNativeZoom: 18
      },
      gsi1961: {
        template:
          "https://cyberjapandata.gsi.go.jp/xyz/ort_old10/{z}/{x}/{y}.png",
        maxZoom: 22,
        maxNativeZoom: 18
      },
      gsi1984: {
        template:
          "https://cyberjapandata.gsi.go.jp/xyz/gazo3/{z}/{x}/{y}.jpg",
        maxZoom: 22,
        maxNativeZoom: 18
      },
      googleSat: {
        template: "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
        maxZoom: 22,
        maxNativeZoom: 21
      },
      googleHybrid: {
        template: "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}",
        maxZoom: 22,
        maxNativeZoom: 21
      },
      googleMaps: {
        template: "https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
        maxZoom: 22,
        maxNativeZoom: 21
      }
    };

    // ===== Helpers =====
    function lngLatToMeters(lng, lat) {
      const x = (lng * Math.PI * R) / 180;
      const y = R * Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI) / 360));
      return { x, y };
    }

    function metersToLngLat(x, y) {
      const lng = (x / R) * (180 / Math.PI);
      const lat =
        (180 / Math.PI) *
        (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2);
      return { lng, lat };
    }

    function latLngToWorldPx(lat, lng, z) {
      const scale = TILE_SIZE * Math.pow(2, z);
      const x = ((lng + 180) / 360) * scale;
      const sinLat = Math.sin((lat * Math.PI) / 180);
      const y =
        (0.5 -
          Math.log((1 + sinLat) / (1 - sinLat)) / (4 * Math.PI)) *
        scale;
      return { x, y };
    }

    function getExportBaseSize() {
      // ベースとなる解像度（1ページあたりのターゲットピクセル数の平方根）
      let base;
      switch (exportResolutionMode) {
        case "low":
          base = 800;
          break;
        case "medium":
          base = 2000;
          break;
        case "high":
          base = 3200;
          break;
        case "veryHigh":
          base = 4800;
          break;
        default:
          base = 3200;
          break;
      }

      // グリッド数が多いときは、PDF 全体のピクセル数が大きくなりすぎて
      // jsPDF が RangeError（Invalid string length）を出すので、
      // 1ページあたりのベースサイズを自動的に下げる。
      const pages = Array.isArray(gridCells) ? gridCells.length : 0;

      // 4セル以下（例: 2×2）は今まで通りフル解像度を維持
      if (!pages || pages <= 4) {
        return base;
      }

      // だいたい 2 億ピクセル程度を上限にする（25ページなどでも安全な範囲）
      const maxTotalPixels = 200_000_000; // 200M
      // このとき 1ページあたりの推奨最大サイズ（1辺の長さ）を逆算
      // sqrt(maxTotalPixels / pages)
      const maxPerPageSide = Math.sqrt(maxTotalPixels / pages);

      // jsPDF の 1ページあたりの最大サイズ（内部制限）とも整合を取る
      const PDF_MAX_SIDE = 14000;
      const safePerPageSide = Math.min(maxPerPageSide, PDF_MAX_SIDE);

      // base が安全な上限を超えている場合のみ縮小
      const adjustedBase = Math.min(base, safePerPageSide);

      // あまり小さくなりすぎると意味がないので、最低 800px は確保
      return Math.max(800, Math.round(adjustedBase));
    }
    function getTileTemplate() {
      const cfg = basemapConfigs[currentBaseKey];
      return cfg ? cfg.template : null;
    }

    function buildTileUrl(template, z, x, y) {
      return template
        .replace("{z}", z)
        .replace("{x}", x)
        .replace("{y}", y);
    }

    // Per-cell export zoom to roughly match desired pixel size
    function getTileExportZoomForCell(cell) {
      if (!cell || !cell.bbox) {
        return 18;
      }

      const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;

      const base = getExportBaseSize();

      const sw0 = latLngToWorldPx(minLat, minLng, 0);
      const ne0 = latLngToWorldPx(maxLat, maxLng, 0);
      const w0 = Math.abs(ne0.x - sw0.x);
      const h0 = Math.abs(ne0.y - sw0.y);
      const long0 = Math.max(w0, h0);
      if (!isFinite(long0) || long0 <= 0) {
        return 18;
      }

      let z = Math.log2(base / long0);
      if (!isFinite(z)) {
        return 18;
      }
      z = Math.round(z);

      const cfg = basemapConfigs[currentBaseKey];
      let maxNative = (cfg && typeof cfg.maxNativeZoom === "number")
        ? cfg.maxNativeZoom
        : 22;
      const maxAllowed = maxNative + 2;
      z = Math.max(0, Math.min(z, maxAllowed));

      return z;
    }

    async function renderCellViaTiles(cell, tileTemplate) {
      const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;
      const z = getTileExportZoomForCell(cell);

      const swPx = latLngToWorldPx(minLat, minLng, z);
      const nePx = latLngToWorldPx(maxLat, maxLng, z);

      const minPxX = Math.min(swPx.x, nePx.x);
      const maxPxX = Math.max(swPx.x, nePx.x);
      const minPxY = Math.min(swPx.y, nePx.y);
      const maxPxY = Math.max(swPx.y, nePx.y);

      const maxIndex = Math.pow(2, z) - 1;
      const minTileX = Math.max(0, Math.floor(minPxX / TILE_SIZE));
      const maxTileX = Math.min(maxIndex, Math.floor(maxPxX / TILE_SIZE));
      const minTileY = Math.max(0, Math.floor(minPxY / TILE_SIZE));
      const maxTileY = Math.min(maxIndex, Math.floor(maxPxY / TILE_SIZE));

      const tilesX = maxTileX - minTileX + 1;
      const tilesY = maxTileY - minTileY + 1;
      const tileCount = tilesX * tilesY;

      const stitchWidth = tilesX * TILE_SIZE;
      const stitchHeight = tilesY * TILE_SIZE;

      const stitchCanvas = document.createElement("canvas");
      stitchCanvas.width = stitchWidth;
      stitchCanvas.height = stitchHeight;
      const ctx = stitchCanvas.getContext("2d");

      const loadPromises = [];
      for (let ty = minTileY; ty <= maxTileY; ty++) {
        for (let tx = minTileX; tx <= maxTileX; tx++) {
          const dx = (tx - minTileX) * TILE_SIZE;
          const dy = (ty - minTileY) * TILE_SIZE;
          const url = buildTileUrl(tileTemplate, z, tx, ty);
          loadPromises.push(
            new Promise((resolve) => {
              const img = new Image();
              img.crossOrigin = "anonymous";
              img.onload = function () {
                try {
                  ctx.drawImage(img, dx, dy);
                } catch (e) {
                  console.warn("drawImage failed for", url, e);
                }
                resolve(true);
              };
              img.onerror = function () {
                console.warn("tile load failed:", url);
                resolve(false);
              };
              img.src = url;
            })
          );
        }
      }

      await Promise.all(loadPromises);

      const originWorldX = minTileX * TILE_SIZE;
      const originWorldY = minTileY * TILE_SIZE;

      const cropX = Math.round(minPxX - originWorldX);
      const cropY = Math.round(minPxY - originWorldY);
      const cropW = Math.round(maxPxX - minPxX);
      const cropH = Math.round(maxPxY - minPxY);

      const cropCanvas = document.createElement("canvas");
      cropCanvas.width = cropW;
      cropCanvas.height = cropH;
      const cropCtx = cropCanvas.getContext("2d");

      cropCtx.drawImage(
        stitchCanvas,
        cropX,
        cropY,
        cropW,
        cropH,
        0,
        0,
        cropW,
        cropH
      );

      // PDF scaling: only clamp to jsPDF's per-page max size; no global pixel budget
      const PDF_MAX_SIDE = 14000;
      const maxSide = Math.max(cropW, cropH);

      let scale = 1;
      if (maxSide > PDF_MAX_SIDE) {
        scale = PDF_MAX_SIDE / maxSide;
      }

      if (scale >= 0.999) {
        // No significant scaling needed; return native resolution
        return { canvas: cropCanvas, width: cropW, height: cropH, tileCount };
      }

      const targetW = Math.max(1, Math.round(cropW * scale));
      const targetH = Math.max(1, Math.round(cropH * scale));

      const scaledCanvas = document.createElement("canvas");
      scaledCanvas.width = targetW;
      scaledCanvas.height = targetH;
      const scaledCtx = scaledCanvas.getContext("2d");
      scaledCtx.drawImage(
        cropCanvas,
        0,
        0,
        cropW,
        cropH,
        0,
        0,
        targetW,
        targetH
      );

      return { canvas: scaledCanvas, width: targetW, height: targetH, tileCount };
    }

    function setStatus(msg) {
      const el = document.getElementById("statusText");
      if (!el) return;
      el.textContent = msg || "";
    }

    function setGridDimensionsText(msg) {
      const el = document.getElementById("gridDims");
      if (!el) return;
      el.textContent = msg || "";
    }

    function setExportOverlay(text, detail, progressFraction) {
      const container = document.getElementById("exportOverlay");
      if (!container) return;
      const textEl = document.getElementById("exportOverlayText");
      const detailEl = document.getElementById("exportOverlayDetail");
      const barOuter = document.getElementById("exportProgressBar");
      const barInner = document.getElementById("exportProgressBarInner");

      if (text && text.length) {
        if (textEl) textEl.textContent = text;
        if (detailEl) detailEl.textContent = detail || "";
        container.style.display = "flex";

        if (typeof progressFraction === "number" && barOuter && barInner) {
          const clamped = Math.max(0, Math.min(1, progressFraction));
          barOuter.style.display = "block";
          barInner.style.width = (clamped * 100).toFixed(1) + "%";
        } else if (barOuter && barInner) {
          barOuter.style.display = "none";
          barInner.style.width = "0%";
        }
      } else {
        container.style.display = "none";
        if (detailEl) detailEl.textContent = "";
        if (barOuter && barInner) {
          barOuter.style.display = "none";
          barInner.style.width = "0%";
        }
      }
    }

    // ===== URL sync =====
    function updateUrlFromState() {
      if (!map) return;
      const params = new URLSearchParams();

      const center = map.getCenter();
      params.set("lat", center.lat.toFixed(6));
      params.set("lng", center.lng.toFixed(6));
      params.set("zoom", map.getZoom().toFixed(2));

      const basemapSelect = document.getElementById("basemapSelect");
      if (basemapSelect) {
        params.set("basemap", basemapSelect.value);
      }

      const rowsInput = document.getElementById("rows");
      const colsInput = document.getElementById("cols");
      if (rowsInput && colsInput && gridCells.length) {
        params.set("rows", rowsInput.value);
        params.set("cols", colsInput.value);
      }

      if (gridCells.length) {
        let minLng = Infinity, minLat = Infinity;
        let maxLng = -Infinity, maxLat = -Infinity;
        gridCells.forEach((cell) => {
          const [[cMinLng, cMinLat], [cMaxLng, cMaxLat]] = cell.bbox;
          if (cMinLng < minLng) minLng = cMinLng;
          if (cMinLat < minLat) minLat = cMinLat;
          if (cMaxLng > maxLng) maxLng = cMaxLng;
          if (cMaxLat > maxLat) maxLat = cMaxLat;
        });
        if (
          isFinite(minLng) && isFinite(minLat) &&
          isFinite(maxLng) && isFinite(maxLat)
        ) {
          params.set("gswLng", minLng.toFixed(6));
          params.set("gswLat", minLat.toFixed(6));
          params.set("gneLng", maxLng.toFixed(6));
          params.set("gneLat", maxLat.toFixed(6));
        }
        params.set("paper", paperMode);
      }
      params.set("orient", paperOrientation);

      const showBoundariesEl = document.getElementById("showBoundaries");
      if (showBoundariesEl) {
        params.set("boundaries", showBoundariesEl.checked ? "1" : "0");
      }

      const lockEl = document.getElementById("lockGrid");
      if (lockEl) {
        params.set("lock", lockEl.checked ? "1" : "0");
      }

      const zoomInputEl = document.getElementById("zoomLevel");
      if (zoomInputEl) {
        params.set("gridZoom", zoomInputEl.value);
      }

      const qs = params.toString();
      const newUrl = qs
        ? `${window.location.pathname}?${qs}`
        : window.location.pathname;
      window.history.replaceState(null, "", newUrl);
    }

    // ===== Grid drawing & dragging =====
    function buildGridGeoJSON(cells) {
      return {
        type: "FeatureCollection",
        features: cells.map((cell) => {
          const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;
          return {
            type: "Feature",
            properties: {
              row: cell.row,
              col: cell.col,
              id: `r${cell.row + 1}_c${cell.col + 1}`
            },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [minLng, minLat],
                [maxLng, minLat],
                [maxLng, maxLat],
                [minLng, maxLat],
                [minLng, minLat]
              ]]
            }
          };
        })
      };
    }

    function ensureGridLayer() {
      if (!map) return;
      const src = map.getSource("grid");
      if (src && src.setData) {
        src.setData(buildGridGeoJSON(gridCells));
      }
    }

    function pointInAnyCell(lng, lat) {
      for (const cell of gridCells) {
        const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;
        if (
          lng >= minLng && lng <= maxLng &&
          lat >= minLat && lat <= maxLat
        ) {
          return true;
        }
      }
      return false;
    }

    function onMapMouseDown(e) {
      if (!map || !gridCells.length || gridLocked) return;
      const { lng, lat } = e.lngLat;
      if (!pointInAnyCell(lng, lat)) return;

      const m = lngLatToMeters(lng, lat);
      dragStartMeters = m;
      dragStartCells = gridCells.map((cell) => ({
        row: cell.row,
        col: cell.col,
        bbox: [
          [cell.bbox[0][0], cell.bbox[0][1]],
          [cell.bbox[1][0], cell.bbox[1][1]]
        ]
      }));
      isDraggingGrid = true;

      if (map.dragPan) {
        map.dragPan.disable();
      }
      if (e.originalEvent) {
        e.originalEvent.preventDefault();
        e.originalEvent.stopPropagation();
      }
    }

    function onGridDragMove(e) {
      if (!isDraggingGrid || !map || !dragStartMeters || !dragStartCells) return;
      const { lng, lat } = e.lngLat;
      const currentMeters = lngLatToMeters(lng, lat);
      const dx = currentMeters.x - dragStartMeters.x;
      const dy = currentMeters.y - dragStartMeters.y;

      const newCells = dragStartCells.map((cell) => {
        const [[minLng, minLat], [maxLng, maxLat]] = cell.bbox;
        const minM = lngLatToMeters(minLng, minLat);
        const maxM = lngLatToMeters(maxLng, maxLat);
        const shiftedMin = metersToLngLat(minM.x + dx, minM.y + dy);
        const shiftedMax = metersToLngLat(maxM.x + dx, maxM.y + dy);
        return {
          row: cell.row,
          col: cell.col,
          bbox: [
            [shiftedMin.lng, shiftedMin.lat],
            [shiftedMax.lng, shiftedMax.lat]
          ]
        };
      });

      gridCells = newCells;
      ensureGridLayer();
    }

    function onGridDragEnd() {
      if (!isDraggingGrid) return;
      isDraggingGrid = false;
      dragStartMeters = null;
      dragStartCells = null;
      if (map && map.dragPan) {
        map.dragPan.enable();
      }
      updateUrlFromState();
    }

    // ===== Map initialization =====
    function createMap() {
      const initialCenter = [136.03, 35.35]; // [lng,lat]
      const initialZoom = 11;

      const style = {
        version: 8,
        sources: {
          esri: {
            type: "raster",
            tiles: [basemapConfigs.esri.template],
            tileSize: 256,
            maxzoom: basemapConfigs.esri.maxZoom
          },
          gsi1974: {
            type: "raster",
            tiles: [basemapConfigs.gsi1974.template],
            tileSize: 256,
            maxzoom: basemapConfigs.gsi1974.maxZoom
          },
          gsiPresent: {
            type: "raster",
            tiles: [basemapConfigs.gsiPresent.template],
            tileSize: 256,
            maxzoom: basemapConfigs.gsiPresent.maxZoom
          },
          gsi1961: {
            type: "raster",
            tiles: [basemapConfigs.gsi1961.template],
            tileSize: 256,
            maxzoom: basemapConfigs.gsi1961.maxZoom
          },
          gsi1984: {
            type: "raster",
            tiles: [basemapConfigs.gsi1984.template],
            tileSize: 256,
            maxzoom: basemapConfigs.gsi1984.maxZoom
          },
          googleSat: {
            type: "raster",
            tiles: [basemapConfigs.googleSat.template],
            tileSize: 256,
            maxzoom: basemapConfigs.googleSat.maxZoom
          },
          googleHybrid: {
            type: "raster",
            tiles: [basemapConfigs.googleHybrid.template],
            tileSize: 256,
            maxzoom: basemapConfigs.googleHybrid.maxZoom
          },
          googleMaps: {
            type: "raster",
            tiles: [basemapConfigs.googleMaps.template],
            tileSize: 256,
            maxzoom: basemapConfigs.googleMaps.maxZoom
          },
          grid: {
            type: "geojson",
            data: { type: "FeatureCollection", features: [] }
          },
          overlay: {
            type: "geojson",
            data: { type: "FeatureCollection", features: [] }
          }
        },
        layers: [
          { id: "esri", type: "raster", source: "esri" },
          {
            id: "gsi1974",
            type: "raster",
            source: "gsi1974",
            layout: { visibility: "none" }
          },
          {
            id: "gsiPresent",
            type: "raster",
            source: "gsiPresent",
            layout: { visibility: "none" }
          },
          {
            id: "gsi1961",
            type: "raster",
            source: "gsi1961",
            layout: { visibility: "none" }
          },
          {
            id: "gsi1984",
            type: "raster",
            source: "gsi1984",
            layout: { visibility: "none" }
          },
          {
            id: "googleSat",
            type: "raster",
            source: "googleSat",
            layout: { visibility: "none" }
          },
          {
            id: "googleHybrid",
            type: "raster",
            source: "googleHybrid",
            layout: { visibility: "none" }
          },
          {
            id: "googleMaps",
            type: "raster",
            source: "googleMaps",
            layout: { visibility: "none" }
          },
          {
            id: "grid-fill",
            type: "fill",
            source: "grid",
            paint: {
              "fill-color": "#f97316",
              "fill-opacity": 0.08
            }
          },
          {
            id: "grid-line",
            type: "line",
            source: "grid",
            paint: {
              "line-color": "#ea580c",
              "line-width": 1.2
            }
          },
          {
            id: "overlay-line",
            type: "line",
            source: "overlay",
            paint: {
              "line-color": "#ef4444",
              "line-width": 2
            }
          }
        ]
      };

      map = new maplibregl.Map({
        container: "map",
        style,
        center: initialCenter,
        zoom: initialZoom
      });

      map.addControl(new maplibregl.NavigationControl(), "top-right");

      map.on("load", () => {
        map.on("moveend", updateUrlFromState);
        map.on("zoomend", () => {
          const zInput = document.getElementById("zoomLevel");
          if (zInput) {
            zInput.value = map.getZoom().toFixed(0);
          }
          updateUrlFromState();
        });

        map.on("mousedown", onMapMouseDown);
        map.on("mousemove", onGridDragMove);
        map.on("mouseup", onGridDragEnd);
      });
    }

    function setBasemap(key) {
      if (!map || !basemapConfigs[key]) return;
      currentBaseKey = key;
      const ids = Object.keys(basemapConfigs);
      ids.forEach((id) => {
        const vis = id === key ? "visible" : "none";
        if (map.getLayer(id)) {
          map.setLayoutProperty(id, "visibility", vis);
        }
      });
    }

    // ===== Grid creation =====
    function generateGrid() {
      if (!map) return;

      const rows = Math.max(
        1,
        parseInt(document.getElementById("rows").value, 10) || 1
      );
      const cols = Math.max(
        1,
        parseInt(document.getElementById("cols").value, 10) || 1
      );

      const bounds = map.getBounds();
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();

      const swM = lngLatToMeters(sw.lng, sw.lat);
      const neM = lngLatToMeters(ne.lng, ne.lat);

      const viewWidth = neM.x - swM.x;
      const viewHeight = neM.y - swM.y;

      let swMAdj = { x: swM.x, y: swM.y };
      let neMAdj = { x: neM.x, y: neM.y };
      let totalW = viewWidth;
      let totalH = viewHeight;

      const centerX = (swM.x + neM.x) / 2;
      const centerY = (swM.y + neM.y) / 2;

      if (paperMode === "A3" || paperMode === "A4") {
        const longOverShort = Math.SQRT2;
        const targetAR =
          paperOrientation === "landscape"
            ? longOverShort
            : 1 / longOverShort;

        const maxCellHeightByHeight = viewHeight / rows;
        const maxCellHeightByWidth = viewWidth / (cols * targetAR);
        const cellHeightMeters = Math.min(
          maxCellHeightByHeight,
          maxCellHeightByWidth
        );
        const cellWidthMeters = cellHeightMeters * targetAR;

        totalW = cellWidthMeters * cols;
        totalH = cellHeightMeters * rows;

        const halfW = totalW / 2;
        const halfH = totalH / 2;
        swMAdj = { x: centerX - halfW, y: centerY - halfH };
        neMAdj = { x: centerX + halfW, y: centerY + halfH };
      }

      const cellW = totalW / cols;
      const cellH = totalH / rows;

      const cells = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const minX = swMAdj.x + c * cellW;
          const maxX = minX + cellW;
          const minY = swMAdj.y + r * cellH;
          const maxY = minY + cellH;

          const swLL = metersToLngLat(minX, minY);
          const neLL = metersToLngLat(maxX, maxY);

          const bbox = [
            [swLL.lng, swLL.lat],
            [neLL.lng, neLL.lat]
          ];
          cells.push({ row: r, col: c, bbox });
        }
      }

      gridCells = cells;
      ensureGridLayer();

      const gridSwLL = metersToLngLat(swMAdj.x, swMAdj.y);
      const gridNeLL = metersToLngLat(neMAdj.x, neMAdj.y);
      const centerLat = (gridSwLL.lat + gridNeLL.lat) / 2;
      const metersPerDegLat = (2 * Math.PI * R) / 360;
      const metersPerDegLng =
        ((2 * Math.PI * R) / 360) * Math.cos((centerLat * Math.PI) / 180);

      const gridWidthKmApprox =
        ((gridNeLL.lng - gridSwLL.lng) * metersPerDegLng) / 1000;
      const gridHeightKmApprox =
        ((gridNeLL.lat - gridSwLL.lat) * metersPerDegLat) / 1000;

      const cellWidthKmApprox = gridWidthKmApprox / cols;
      const cellHeightKmApprox = gridHeightKmApprox / rows;
      const cellAspect =
        cellHeightKmApprox !== 0
          ? cellWidthKmApprox / cellHeightKmApprox
          : NaN;

      const zoomNow = map.getZoom();
      gridZoomForExport = zoomNow;

      const dimsText = `現在のグリッド: ズーム ${zoomNow.toFixed(
        0
      )}, 全体 ≈ ${gridWidthKmApprox.toFixed(
        3
      )} × ${gridHeightKmApprox.toFixed(
        3
      )} km; 1セル ≈ ${cellWidthKmApprox.toFixed(
        3
      )} × ${cellHeightKmApprox.toFixed(
        3
      )} km (縦横比 ${
        isFinite(cellAspect) ? cellAspect.toFixed(3) : "–"
      }, 用紙モード ${paperMode} / ${
        paperOrientation === "landscape" ? "横" : "縦"
      }).`;

      setGridDimensionsText(dimsText);
      setStatus(`グリッドを作成しました: ${rows} × ${cols}。${dimsText}`);

      const zoomInputEl = document.getElementById("zoomLevel");
      if (zoomInputEl) {
        zoomInputEl.value = zoomNow.toFixed(0);
      }

      updateUrlFromState();
    }

    // ===== Search =====
    function searchLocation() {
      if (!map) return;
      const q = document.getElementById("searchInput").value.trim();
      if (!q) return;
      setStatus(`「${q}」を検索中です…`);
      fetch(
        "https://nominatim.openstreetmap.org/search?format=json&q=" +
          encodeURIComponent(q)
      )
        .then((res) => res.json())
        .then((data) => {
          if (!data || !data.length) {
            setStatus(`「${q}」は見つかりませんでした。`);
            return;
          }
          const best = data[0];
          const lat = parseFloat(best.lat);
          const lon = parseFloat(best.lon);
          map.flyTo({ center: [lon, lat], zoom: 12 });
          setStatus("場所を移動しました: " + best.display_name);
        })
        .catch((err) => {
          console.error(err);
          setStatus("検索に失敗しました。もう一度お試しください。");
        });
    }

    // ===== GeoJSON overlay =====
    function loadGeoJSONFromUrl() {
      if (!map) return;
      const input = document.getElementById("geojsonUrl");
      if (!input) return;
      const url = input.value.trim();
      if (!url) {
        setStatus("GeoJSON の URL を入力してください。");
        return;
      }
      setStatus("GeoJSON を読み込み中です...");
      fetch(url)
        .then((res) => {
          if (!res.ok) throw new Error("HTTP " + res.status);
          return res.json();
        })
        .then((data) => {
          const src = map.getSource("overlay");
          if (src && src.setData) {
            src.setData(data);
          }
          // Simple fit bounds
          try {
            let minLng = Infinity, minLat = Infinity;
            let maxLng = -Infinity, maxLat = -Infinity;
            const walk = (geom) => {
              if (!geom) return;
              const type = geom.type;
              if (type === "Point") {
                const [lng, lat] = geom.coordinates;
                if (lng < minLng) minLng = lng;
                if (lat < minLat) minLat = lat;
                if (lng > maxLng) maxLng = lng;
                if (lat > maxLat) maxLat = lat;
              } else if (type === "LineString" || type === "MultiPoint") {
                geom.coordinates.forEach(([lng, lat]) => {
                  if (lng < minLng) minLng = lng;
                  if (lat < minLat) minLat = lat;
                  if (lng > maxLng) maxLng = lng;
                  if (lat > maxLat) maxLat = lat;
                });
              } else if (type === "Polygon" || type === "MultiLineString") {
                geom.coordinates.forEach((ring) =>
                  ring.forEach(([lng, lat]) => {
                    if (lng < minLng) minLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lng > maxLng) maxLng = lng;
                    if (lat > maxLat) maxLat = lat;
                  })
                );
              } else if (type === "MultiPolygon") {
                geom.coordinates.forEach((poly) =>
                  poly.forEach((ring) =>
                    ring.forEach(([lng, lat]) => {
                      if (lng < minLng) minLng = lng;
                      if (lat < minLat) minLat = lat;
                      if (lng > maxLng) maxLng = lng;
                      if (lat > maxLat) maxLat = lat;
                    })
                  )
                );
              } else if (type === "GeometryCollection") {
                geom.geometries.forEach(walk);
              }
            };

            if (data.type === "FeatureCollection") {
              data.features.forEach((f) => walk(f.geometry));
            } else if (data.type === "Feature") {
              walk(data.geometry);
            } else {
              walk(data);
            }

            if (
              isFinite(minLng) && isFinite(minLat) &&
              isFinite(maxLng) && isFinite(maxLat)
            ) {
              map.fitBounds(
                [
                  [minLng, minLat],
                  [maxLng, maxLat]
                ],
                { padding: 20, duration: 800 }
              );
            }
          } catch (e) {
            console.warn("Could not fit bounds for GeoJSON overlay:", e);
          }
          setStatus("GeoJSON レイヤーを読み込みました。");
        })
        .catch((err) => {
          console.error(err);
          setStatus("GeoJSON の読み込みに失敗しました。CORS や URL を確認してください。");
        });
    }

    function clearGeoJSONOverlay() {
      if (!map) return;
      const src = map.getSource("overlay");
      if (src && src.setData) {
        src.setData({ type: "FeatureCollection", features: [] });
      }
      setStatus("GeoJSON レイヤーをクリアしました。");
    }

    // ===== Export current view (PNG) via MapLibre canvas =====
    function exportCurrentView() {
      if (!map) return;
      const showBoundariesEl = document.getElementById("showBoundaries");
      const showBoundaries = !showBoundariesEl || showBoundariesEl.checked;

      const hideGrid = !showBoundaries;
      if (hideGrid && map.getLayer("grid-line") && map.getLayer("grid-fill")) {
        map.setLayoutProperty("grid-line", "visibility", "none");
        map.setLayoutProperty("grid-fill", "visibility", "none");
      }

      try {
        const canvas = map.getCanvas();
        const dataURL = canvas.toDataURL("image/png");
        const link = document.createElement("a");
        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        link.href = dataURL;
        link.download = `map_view_${ts}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setStatus("現在の表示を PNG として保存しました。");
      } catch (e) {
        console.error(e);
        setStatus("エクスポートに失敗しました（ブラウザの権限を確認してください）。");
      } finally {
        if (hideGrid && map.getLayer("grid-line") && map.getLayer("grid-fill")) {
          map.setLayoutProperty("grid-line", "visibility", "visible");
          map.setLayoutProperty("grid-fill", "visibility", "visible");
        }
      }
    }

    // ===== Export all cells to one PDF (tile-based, native resolution) =====
    async function exportAllCells() {
      if (!map) return;
      if (!gridCells.length) {
        alert("先にグリッドを作成してください。");
        return;
      }

      const tileTemplate = getTileTemplate();
      if (!tileTemplate) {
        setStatus("現在のベースマップはタイルエクスポートに対応していません。別のベースマップを試してください。");
        return;
      }

      exportCancelRequested = false;

      const exportBtn = document.getElementById("exportBtn");
      const exportOneBtn = document.getElementById("exportOneBtn");
      exportBtn.disabled = true;
      exportOneBtn.disabled = true;

      const { jsPDF } = window.jspdf;
      let pdf = null;

      const total = gridCells.length;
      exportTotalCells = total;
      let totalTilesSoFar = 0;

      const showBoundariesEl = document.getElementById("showBoundaries");
      const showBoundaries = !showBoundariesEl || showBoundariesEl.checked;

      setStatus(`セル 1 / ${total} を出力中...`);
      setExportOverlay(`セル 1 / ${total} を出力中...`, "", 0);

      function finalizeExport({ save, message }) {
        if (save && pdf) {
          pdf.save("map_grid.pdf");
        }
        exportTotalCells = 0;
        exportBtn.disabled = false;
        exportOneBtn.disabled = false;
        setStatus(message);
        setExportOverlay("");
      }

      try {
        for (let index = 0; index < total; index++) {
          if (exportCancelRequested) {
            finalizeExport({
              save: false,
              message: "エクスポートをキャンセルしました。"
            });
            return;
          }

          const cell = gridCells[index];
          const stepText = `セル ${index + 1} / ${total} を出力中...`;
          setStatus(stepText);

          const {
            canvas: cropCanvas,
            width: cropW,
            height: cropH,
            tileCount
          } = await renderCellViaTiles(cell, tileTemplate);

          totalTilesSoFar += (tileCount || 0);
          const detailText = `このセル: 約 ${tileCount || 0} タイル / 累計: 約 ${totalTilesSoFar} タイル`;
          const progress = total > 0 ? (index + 1) / total : 0;
          setExportOverlay(stepText, detailText, progress);

          if (showBoundaries) {
            const bctx = cropCanvas.getContext("2d");
            const lw = Math.max(1, Math.round(Math.min(cropW, cropH) / 400));
            bctx.strokeStyle = "rgba(234,88,12,0.9)";
            bctx.lineWidth = lw;
            bctx.strokeRect(
              lw / 2,
              lw / 2,
              cropW - lw,
              cropH - lw
            );
          }

          const dataURL = cropCanvas.toDataURL("image/png");

          if (!pdf) {
            const orientation = cropW >= cropH ? "landscape" : "portrait";
            pdf = new jsPDF({
              orientation,
              unit: "px",
              format: [cropW, cropH]
            });
          } else {
            pdf.addPage(
              [cropW, cropH],
              cropW >= cropH ? "landscape" : "portrait"
            );
          }

          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();
          pdf.addImage(dataURL, "PNG", 0, 0, pageWidth, pageHeight);
        }

        finalizeExport({
          save: true,
          message: `エクスポート完了: ${total} セルを PDF に保存しました。`
        });
      } catch (e) {
        console.error(e);
        finalizeExport({
          save: !!pdf,
          message: "タイルエクスポート中にエラーが発生しました。"
        });
      }
    }

    // ===== DOMContentLoaded wiring =====
    window.addEventListener("DOMContentLoaded", () => {
      const params = new URLSearchParams(window.location.search);

      createMap();

      const zoomInputEl = document.getElementById("zoomLevel");
      if (zoomInputEl && map) {
        zoomInputEl.value = map.getZoom().toFixed(0);
      }

      const lockEl = document.getElementById("lockGrid");
      if (lockEl) {
        if (params.has("lock")) {
          lockEl.checked = params.get("lock") === "1";
        }
        gridLocked = lockEl.checked;
        lockEl.addEventListener("change", () => {
          gridLocked = lockEl.checked;
          updateUrlFromState();
        });
      }

      const showBoundariesEl = document.getElementById("showBoundaries");
      if (showBoundariesEl) {
        if (params.has("boundaries")) {
          showBoundariesEl.checked = params.get("boundaries") !== "0";
        }
        showBoundariesEl.addEventListener("change", () => {
          updateUrlFromState();
        });
      }

      const basemapSelect = document.getElementById("basemapSelect");
      if (basemapSelect && params.has("basemap")) {
        const key = params.get("basemap");
        if (key && basemapConfigs[key]) {
          basemapSelect.value = key;
          setBasemap(key);
        }
      }

      if (params.has("lat") && params.has("lng")) {
        const lat = parseFloat(params.get("lat"));
        const lng = parseFloat(params.get("lng"));
        if (isFinite(lat) && isFinite(lng)) {
          let zoom = map.getZoom();
          if (params.has("zoom")) {
            const zParam = parseFloat(params.get("zoom"));
            if (isFinite(zParam)) zoom = zParam;
          }
          map.jumpTo({ center: [lng, lat], zoom });
          if (zoomInputEl) zoomInputEl.value = zoom.toFixed(0);
        }
      } else if (params.has("zoom")) {
        const zParam = parseFloat(params.get("zoom"));
        if (isFinite(zParam)) {
          const c = map.getCenter();
          map.jumpTo({ center: [c.lng, c.lat], zoom: zParam });
          if (zoomInputEl) zoomInputEl.value = zParam.toFixed(0);
        }
      }

      const rowsInput = document.getElementById("rows");
      const colsInput = document.getElementById("cols");
      if (rowsInput && params.has("rows")) {
        rowsInput.value = params.get("rows");
      }
      if (colsInput && params.has("cols")) {
        colsInput.value = params.get("cols");
      }
      if (zoomInputEl && params.has("gridZoom")) {
        zoomInputEl.value = params.get("gridZoom");
        const gz = parseFloat(params.get("gridZoom"));
        if (isFinite(gz)) {
          gridZoomForExport = gz;
        }
      }

      if (params.has("paper")) {
        const p = params.get("paper");
        if (p === "A3" || p === "A4" || p === "custom") {
          paperMode = p;
        }
      }
      if (params.has("orient")) {
        const o = params.get("orient");
        if (o === "landscape" || o === "portrait") {
          paperOrientation = o;
        }
      }

      // Restore grid from URL if present
      if (
        params.has("rows") &&
        params.has("cols") &&
        params.has("gswLng") &&
        params.has("gswLat") &&
        params.has("gneLng") &&
        params.has("gneLat")
      ) {
        const rows = Math.max(1, parseInt(params.get("rows"), 10) || 1);
        const cols = Math.max(1, parseInt(params.get("cols"), 10) || 1);
        const swLng = parseFloat(params.get("gswLng"));
        const swLat = parseFloat(params.get("gswLat"));
        const neLng = parseFloat(params.get("gneLng"));
        const neLat = parseFloat(params.get("gneLat"));

        if (
          isFinite(swLng) && isFinite(swLat) &&
          isFinite(neLng) && isFinite(neLat)
        ) {
          const swM = lngLatToMeters(swLng, swLat);
          const neM = lngLatToMeters(neLng, neLat);
          const totalW = neM.x - swM.x;
          const totalH = neM.y - swM.y;
          const cellW = totalW / cols;
          const cellH = totalH / rows;

          const cells = [];
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const minX = swM.x + c * cellW;
              const maxX = minX + cellW;
              const minY = swM.y + r * cellH;
              const maxY = minY + cellH;

              const swLL = metersToLngLat(minX, minY);
              const neLL = metersToLngLat(maxX, maxY);

              const bbox = [
                [swLL.lng, swLL.lat],
                [neLL.lng, neLL.lat]
              ];
              cells.push({ row: r, col: c, bbox });
            }
          }

          gridCells = cells;
          ensureGridLayer();

          const gridSwLL = { lng: swLng, lat: swLat };
          const gridNeLL = { lng: neLng, lat: neLat };
          const centerLat = (gridSwLL.lat + gridNeLL.lat) / 2;
          const metersPerDegLat = (2 * Math.PI * R) / 360;
          const metersPerDegLng =
            ((2 * Math.PI * R) / 360) * Math.cos((centerLat * Math.PI) / 180);

          const gridWidthKmApprox =
            ((gridNeLL.lng - gridSwLL.lng) * metersPerDegLng) / 1000;
          const gridHeightKmApprox =
            ((gridNeLL.lat - gridSwLL.lat) * metersPerDegLat) / 1000;

          const cellWidthKmApprox = gridWidthKmApprox / cols;
          const cellHeightKmApprox = gridHeightKmApprox / rows;
          const cellAspect =
            cellHeightKmApprox !== 0
              ? cellWidthKmApprox / cellHeightKmApprox
              : NaN;

          const zoomNow = map.getZoom();
          gridZoomForExport = zoomNow;

          const dimsText = `現在のグリッド: ズーム ${zoomNow.toFixed(
            0
          )}, 全体 ≈ ${gridWidthKmApprox.toFixed(
            3
          )} × ${gridHeightKmApprox.toFixed(
            3
          )} km; 1セル ≈ ${cellWidthKmApprox.toFixed(
            3
          )} × ${cellHeightKmApprox.toFixed(
            3
          )} km (縦横比 ${
              isFinite(cellAspect) ? cellAspect.toFixed(3) : "–"
            }, 用紙モード ${paperMode} / ${
              paperOrientation === "landscape" ? "横" : "縦"
            }).`;

          setGridDimensionsText(dimsText);
          setStatus(`URL からグリッドを復元しました。${dimsText}`);

          if (!(params.has("lat") && params.has("lng"))) {
            map.fitBounds(
              [
                [swLng, swLat],
                [neLng, neLat]
              ],
              { padding: 20, duration: 0 }
            );
          }
        }
      }

      // Paper preset buttons
      const paperButtons = Array.from(document.querySelectorAll(".paper-btn"));
      function updatePaperButtons() {
        paperButtons.forEach((btn) => {
          const mode = btn.getAttribute("data-paper");
          if (mode === paperMode) {
            btn.classList.add("paper-active");
          } else {
            btn.classList.remove("paper-active");
          }
        });
      }
      paperButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const mode = btn.getAttribute("data-paper");
          if (!mode) return;
          paperMode = mode;
          updatePaperButtons();
          setStatus(
            `用紙モードを ${paperMode} に変更しました。グリッドを再生成してください。`
          );
          updateUrlFromState();
        });
      });
      updatePaperButtons();

      // Orientation buttons
      const orientButtons = Array.from(document.querySelectorAll(".orient-btn"));
      function updateOrientButtons() {
        orientButtons.forEach((btn) => {
          const o = btn.getAttribute("data-orient");
          if (o === paperOrientation) {
            btn.classList.add("orient-active");
          } else {
            btn.classList.remove("orient-active");
          }
        });
      }
      orientButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const o = btn.getAttribute("data-orient");
          if (!o) return;
          if (o === "landscape" || o === "portrait") {
            paperOrientation = o;
            updateOrientButtons();
            setStatus(
              `用紙の向きを ${
                paperOrientation === "landscape" ? "横" : "縦"
              } に変更しました。グリッドを再生成してください。`
            );
            updateUrlFromState();
          }
        });
      });
      updateOrientButtons();

      // Buttons / controls
      document
        .getElementById("generateGridBtn")
        .addEventListener("click", generateGrid);

      document
        .getElementById("basemapSelect")
        .addEventListener("change", (e) => {
          setBasemap(e.target.value);
          updateUrlFromState();
        });

      document
        .getElementById("exportBtn")
        .addEventListener("click", exportAllCells);

      document
        .getElementById("exportOneBtn")
        .addEventListener("click", exportCurrentView);

      document
        .getElementById("searchBtn")
        .addEventListener("click", searchLocation);

      document
        .getElementById("searchInput")
        .addEventListener("keydown", (e) => {
          if (e.key === "Enter") searchLocation();
        });

      const loadGeojsonBtn = document.getElementById("loadGeojsonBtn");
      if (loadGeojsonBtn) {
        loadGeojsonBtn.addEventListener("click", loadGeoJSONFromUrl);
      }
      const clearGeojsonBtn = document.getElementById("clearGeojsonBtn");
      if (clearGeojsonBtn) {
        clearGeojsonBtn.addEventListener("click", clearGeoJSONOverlay);
      }

      const exportResSelect = document.getElementById("exportRes");
      if (exportResSelect) {
        exportResSelect.value = exportResolutionMode;
        exportResSelect.addEventListener("change", (e) => {
          const val = e.target.value;
          if (
            val === "low" ||
            val === "medium" ||
            val === "high" ||
            val === "veryHigh"
          ) {
            exportResolutionMode = val;
          } else {
            exportResolutionMode = "high";
          }
        });
      }

      const cancelBtn = document.getElementById("cancelExportBtn");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", () => {
          if (!exportCancelRequested) {
            exportCancelRequested = true;
            setStatus("エクスポートをキャンセルしています...");
          }
        });
      }

      updateUrlFromState();
    });
  </script>
</body>
</html>